# 数据结构和算法

## 算法复杂度

1、时间复杂度

2、空间复杂度

## 排序

### 排序表格

| 中文名称 | 英文名称 | 时间复杂度 | 空间复杂度 | 稳定性
| ------ | ------ | ------ | ------ |  ------ |
| 选择排序 | Selection | O(n^2) | O(1) | 不稳 | 
| 冒泡排序 | Bubble | O(n^2) | O(1) | 稳定 |
| 插入排序 | Insertion | O(n^2) | O(1) | 稳定 |
| 希尔排序 | Shell | O(n^1.3)| O(1) | 不稳定 |
| 归并排序 | Merge | O(N*logN) | O(n) | 稳定 |
| 快速排序 | Quick | O(N*logN) | O(logN) | 不稳定 |
| 计数排序 | Counting | O(n+k) | O(n+k) | 不稳定 | 
| 基数排序 | Radix | O(n*k) | O(n) | 稳定 | 
| 桶排序 | Bucket | O(n+k) | O(n+k) | 不稳定 |
| 堆排序 | Heap | O(N*logN) | O(1) | 不稳定 |

> 简单排序：选择、冒泡、插入

### 排序思想

- 选择排序
    
    在一组数组中，遍历一遍，挑选出最小的那个值，交换到第一位。
    
    第二轮继续从第二个数开始，重复以上动作，遍历，将最大的放置到第二个位置。
    
    因此需要循环的次数为，n*(n-1)\*(n-2)\*...*2 * 1 次，算法复杂度为 O(n^2)，没有额外的内存开销，空间复杂度为O(1)
    
    因为要做全量对比，所以算法是不稳定的。
    
    由于速度慢，又不稳定，因此一般不使用选择排序。
    
- 冒泡排序

    在一组数组中，取出第一个数，与下一个数据做比较，如果较大，则交换位置。再接着与后面的值做比较。则第一轮可以将最大的那个数，交换到最后一位。
    
    第二轮接着对比，可以挑选出第二大的数，交换到倒数第二位，以此类推。
    
    因此需要循环的次数，同选择排序，算法复杂度为O(n^2)，没有额外的内存开销，空间复杂度为O(1)
    
    因为是两两对比，算法是稳定的。
    
    冒泡排序可以做优化，可以在一轮循环中做上标记，标记此轮冒泡是否交换过数据，如果没有，则表示已经是顺序的，可以提前终止排序。
    
    因此是最好的情况下，冒泡排序的算法复杂度是O(n)
    
    由于效率过慢，一般也不使用冒泡排序
    
- 插入排序

    在一组数组中，第一轮从第二个数开始，往前对比，如果小就交换，大就不变，第一轮可以将前两个数排成顺序的。
    
    第二轮中，从第三个数开始，往前对比，如果小就插入到已排序的数组中，如果大就停止。第二轮可以将前三个数排成顺序的。
    
    以此类推，直到最后一个数。
    
    需要循环的次数为1\*2\*3*\...\*(n-2)*(n-1)，算法复杂度为`O(n^2)`，空间复杂度是`O(1)`
    
    最好的情况下，每次循环只做一次比较，并且不交换。因此此时的算法复杂度是`O(n)`
    
    插入排序也可以做优化。
    
    优化的核心思想是，从第二个数开始，将当前比较的数字，缓存起来当做临时变量，前面的值与缓存比，如果比缓存小，则将数字复制往后移一位。
    
    这样的好处，可以减少空间交换。适当提升性能。
    
    `插入排序`当样本数量较小，且基本有序的情况下，效率较高。

- 希尔排序

    在一组数组中，设置一个间隔，比如间隔为1/2的数组长度，根据间隔将数组分为几个组，小组内先使用插入排序进行比较。
    
    第二轮缩小这个间隔，比如将间隔缩小为1/4的长度，在组内进行排序。以此类推，直到间隔缩小到1。
    
    传统的希尔排序，初始间隔设置为1/2的数组长度。而改进的希尔排序，可以使用Knuth序列。
    
    算法复杂度，经演算，平均时间可以达到O(n^1.3)。没有额外的内存使用，空间复杂度为O(1)。
    
    由于是跳着排序，可能会改变相同元素的相对顺序，因此`希尔排序`是不稳定的。
    
    > 由于希尔排序的不管数组的规则，算法时间是基本稳定的，有些说法是，写算法，先使用希尔排序排一遍，如果时间可以接受，就别使用别的算法了

- 归并排序

    核心思想是对已经有序的两个数组，两边进行轮询对比，进行合并排序，产生新的有序数组。
    
    如何获得有序的数组，则是使用递归，对数组进行切割，获得子数组，直到子数组的长度为1，从长度为1的子数组，进行不断排序
    
    递归回归，再对已排好序的两两数组，进行再次排序，直到结束。
    
    在归并的过程中，将数组分了logN次，每一层交换的次数大概是N次，因此时间复杂度是`O(n*logN)`。
    
    每次递归的过程中，会新建很多新的数组，开辟很多新的存储空间，递归结束后即释放。最多不会超过N个，因此空间复杂度是`O(n)`
    
    对象排序需要稳定，因此一般编程语言内置算法使用归并。
    
- 快速排序

    对一组数组，先选定一个参考值，（一般是数组第一个，或者最后一个）

    此刻对该数组同时指定两个指针，一个指针从数组左边，一个指针从数组右边走。

    左边要找到第一个比该数大的值，右边找到第一个比该参考值小的值，做交换。

    当左右指针相互碰撞时，遍历结束，再将该参考值，移到碰撞点，此刻比该参考值小的数，都在参考值左边，比参考值大的数，都在其右边，参考值在数组中的位置已确定

    以参考值交换的位置作为切割点，对数组进行左右切割，再次获得左右的一次准确点，再次递归，直至获取全部
    
    数组一共被切割成logN次，每次需要做N次交换，因此时间复杂度是`O(N*logN)`
    
    最坏的情况下，数组是顺序的，分成的两部分，每次分割点都在最右边，最坏算法的复杂度是`O(n^2)`
    
    为了避免最坏情况，可以事先判断是否是顺序的，或者随机取一个数先做交换，做key值。
    
    空间复杂度，因为有递归，空间复杂度为：`O(logN)`
    
- 计数排序

    先对数组的值做统计，会拥有哪些值，做一个桶，并对这些数值的每个桶初始化计数为0。
    
    当遍历数组时，遍历到某个值时，某个值对应的桶位计数加1。
    
    普通计数排序是非稳定排序。
    
    可以根据增量记录每个数字的下标临界值，逆序遍历数组，将数组的值从临界下标开始放置，并减去一，可保证原数组顺序不变，可达到稳定态。
    
    计数排序是非交换排序。
    
    时间复杂度是`O(n+k)`
    
    空间复杂度是`O(n+k)`

- 基数排序

    核心思想是一种多关键字排序。 可以从高位到低位，或者从低位到高位，进行排序。
    
    高位优先排序本质上是一种分治思想，从高位开始切割，将相同高位的聚合在一起，并递归对他们的低位逐级进行排序，直到个位。
    
    低位优先排序则是从低位开始排，逐渐排至高位，直至数组的最高位，并将结果返回。
    
    基数排序可以通过算法优化达到稳定。
    
    可以用于字符串的排序。
    
    由于需要建立K(位数)个数组，可以通过程序优化为一次，因此空间复杂度为`O(n)`
    
    由于每个位数排序一次，每次排序时间复杂度为N，时间复杂度为 `O(n*k)`
    
    
- 桶排序

    核心思想是，遍历一遍数组，获取区间。
    
    从小到大平均分配区间相同的桶，再次遍历数组，将数组里的元素，放置到对应区间的桶内。
    
    在桶内进行（快速/归并）排序。
    
    最后再按照桶从小到大进行排序。
    
    算法的时间复杂度是：n+n+log(N/K)*K -- >约等于`O(n+k)`
    
    需要分配额外的所有的桶空间，空间复杂度为`O(n+k)`
    
    实际情况用的很少，更多的是使用计数排序和基数排序。
    
- 堆排序

    核心思想是，首先要建立堆，堆的要求是形成平衡二叉树。需要满足平衡二叉树的条件，并且树的根节点的数字要大于两个子节点。
  
    实现堆化算法之后，可以实现小堆的堆化。
  
    要考虑从哪里开始堆化，答案是从最后一个节点的父节点开始堆化，并递减至根节点，保证整课树堆化。
 
    堆化后，最大值在根节点，将根节点与最后一个子节点交换，此时最后一位已确认。
 
    从首位到倒数第二位开始重新堆化，可以获取第二大的数到根节点，此时倒数第二位已确认。
 
    循环至第一位.即可完成数组排序。
    
    首先需要先建立大堆，每次堆化可以获取最大值，每次堆化的时间复杂度是logN。需要循环N次
    
    因此时间复杂度是`O(N*logN)`
    
    没有额外的空间使用，空间复杂度是`O(1)`

## 查找

- 二叉排序树

    树的左边节点比根节点小，右边比根节点大。
    
    左右子树也都是二叉排序树。
    
    当插入的数据全都是有序的，此时的二叉树会退化成链表。

- 红黑树

    红黑树是平衡树的一种。

    之所以了保证树的平衡性，是因为树的查找性能取决于树的高度，树越平衡，高度越低，效率也就越高。
    
    Java的TreeSet底层使用的就是红黑树。

- B树

    B树是一直多路搜索树，他的每个节点可以拥有多余的两个子节点。M路的B树最多能拥有M个子节点。
    
    路树越多，树的高度越低。当路树无穷多的时候，B树退化成有序数组。
    
    B树一般用于`文件系统索引`。
    
    文件系统和数据库的索引，一般建立在硬盘上，如果数据量过大的话，不能一次性加载到内存中。
    
    如果一棵树无法一次性加载到内存，可以每次只加载B树的一个节点。然后一步步往下找。
    
    如果在内存中，红黑树的效率更高。如果是读取到硬盘里，则B树效率更高。
    
- B+树

    B+树是对B树做的改造。数据全部落在叶子节点上，同时叶子节点还增加指针形成链表。
    
    B+树一般用于`数据库索引`。
    
    select语句一般是选取多条。
    
    如果是选取多条，则需要做局部的中序遍历，并且需要跨层访问。
    
    B+树所有的数据在叶子节点上，不需要跨层。
    
    同时拥有链表结构，只需要把首尾获取到，就可以通过链表把数据全部取出。
    
    > 这里有个问题，B+树取数据的效率，平均的时间复杂度是O(logN)，而Hash散列表查询的效率是O(1)，Hash的速度快于B+树，为什么MySQL还要使用B+树。
    
    如果只取一条数据，确实Hash更快。
    
    而数据库通常是查询多条数据，这时候B+树的索引有序，又有链表相连，因此B+树的效率更高。
    
    数据库的索引一般存储在磁盘上，不可能一次性全部加载到内存里，B+树允许分批加载，因此

### 如何判断自己的算法是否正确

1. 肉眼观察
2. 产生足够多的样本
3. 用已知正确的算法计算样本结果
4. 对比验证算法的结果